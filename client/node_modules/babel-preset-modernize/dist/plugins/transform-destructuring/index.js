"use strict";exports.__esModule=true;exports.default=void 0;var _default=({types:t})=>{function isWithoutPropertiesHelper(path,obj){if(!path.isCallExpression())return false;const args=path.get("arguments");let callee=resolveIntermediaries(path.get("callee"));if(args.length!==2)return false;if(isObjectAssign(callee)){if(!t.isObjectExpression(args[0])||args[0].get("properties").length)return false;if(!t.isIdentifier(almostResolve(args[1]).node,obj.node))return false;elideImport(callee);return true}if(!t.isArrayExpression(args[1]))return false;for(let el of args[1].get("elements")){if(!t.isStringLiteral(el))return false}if(t.isObjectExpression(args[0])&&!args[0].get("properties").length){return true}if(!t.isIdentifier(almostResolve(args[0]).node,obj.node))return false;elideImport(callee);if(t.isMemberExpression(callee)){elideHelper(path.get("callee"));return t.isThisExpression(callee.node.object)&&t.isIdentifier(callee.node.property,{name:"__rest"})}return true}function isSliceHelper(path,ref){if(!t.isMemberExpression(path)){path=resolveIntermediaries(path);if(!t.isMemberExpression(path))return false}let obj=path.get("object");if(!t.isNodesEquivalent(obj.node,ref.node)){obj=almostResolve(obj);if(!t.isNodesEquivalent(obj.node,ref.node)){return false}}if(!t.isIdentifier(path.node.property,{name:"slice"})){return false}return true}function almostResolve(path){path=path.resolve();if(!t.isIdentifier(path)){const parent=path.parentPath;if(t.isVariableDeclarator(parent)){return parent.get("id")}else if(t.isAssignmentExpression(parent)){return parent.get("left")}}return path}function resolveIntermediaries(path){path=path.resolve();if(t.isSequenceExpression(path)){let expr;for(expr of path.get("expressions")){const v=expr.evaluate();if(!v.confident||v.value)break}return resolveIntermediaries(expr)}if(t.isLogicalExpression(path)&&path.node.operator==="&&"&&t.isThisExpression(path.node.left)){return resolveIntermediaries(path.get("right"))}if(t.isLogicalExpression(path)&&path.node.operator==="||"){return resolveIntermediaries(path.get("left"))}if(t.isMemberExpression(path)&&t.isIdentifier(path.node.property,{name:"default"})){return resolveIntermediaries(path.get("object"))}if(t.isCallExpression(path)&&isImportOf(path.get("callee"),"@babel/runtime/helpers/interopRequireDefault")){return resolveIntermediaries(path.get("arguments.0"))}return path}function isImportOf(path,libPattern){path=path.resolve();let specifier;if(t.isCallExpression(path)&&t.isIdentifier(path.node.callee,{name:"require"})){specifier=path.get("arguments.0").node.value}else if(t.isImportSpecifier(path.parent)){specifier=path.parentPath.parentPath.get("source").node.value}if(specifier){if(typeof libPattern==="string"){return specifier===libPattern}return libPattern.test(specifier)}return false}function elideImport(path){if(isImportOf(path,{test:()=>true})){const idents=path.getStatementParent().getBindingIdentifierPaths();for(let ident in idents){const binding=path.scope.getBinding(ident);binding.dereference();if(!binding.referenced){const parent=path.parentPath;if(t.isCallExpression(parent)&&isImportOf(parent.get("callee"),"@babel/runtime/helpers/interopRequireDefault")){elideImport(parent.get("callee").resolve())}binding.path.remove()}}}}function elideHelper(path){if(t.isIdentifier(path)){const p=path.getOuterBindingIdentifierPaths();for(let ident in p){const binding=path.scope.getBinding(ident);binding.dereference();if(!binding.referenced){binding.path.remove()}}}}function isObjectAssign(path){path=path.resolve();if(t.isMemberExpression(path)){const obj=path.get("object").resolve();const prop=path.get("property").resolve();return t.isIdentifier(obj.node,{name:"Object"})&&t.isIdentifier(prop.node,{name:"assign"})}return false}function visitParam(path){if(!t.isIdentifier(path))return;const binding=path.scope.getBinding(path.node.name);if(!binding){console.warn(`No binding for ${path.node.name}`);return}const referencePaths=binding.referencePaths;if(!binding.constant||!referencePaths.length||binding.constantViolations.length)return;let rest;let restOffset,isIterable=false,onlyIfProperties=false,properties=[];const isValidRefPath=p=>{const parent=p.parentPath;const root=parent.parentPath;if(isSliceHelper(parent,path)&&root.node.arguments.length<2){onlyIfProperties=true;rest=root.parentPath;isIterable=true;restOffset=root.get("arguments.0").node.value;return true}else if(t.isMemberExpression(parent)){if(p.key==="object"&&t.isVariableDeclarator(root)){properties.push(root);return true}}else if(isWithoutPropertiesHelper(parent,path)){rest=parent;return true}return false};const isDestructure=referencePaths.every(isValidRefPath);if(!isDestructure)return;if(onlyIfProperties&&!properties.length){return}const pattern=[];const defined=[];for(let prop of properties){let id=prop.node.init.property;let computed=prop.node.init.computed;let v=t.isIdentifier(id)?id.name:null;if(computed){const resolved=prop.get("init.property").resolve().node;if(t.isLiteral(resolved)){v=String(resolved.value);computed=false;if(/^[a-z0-9$_]*$/gi.test(v)){id=t.identifier(v)}else{id=t.stringLiteral(v)}}else{const evaluated=prop.get("init.property").evaluate();if(evaluated.confident){v=String(evaluated.value);computed=false;if(/^[a-z0-9$_]*$/gi.test(v)){id=t.identifier(v)}else{id=t.stringLiteral(v)}}else{return}}}if(isIterable){pattern[v]=t.clone(prop.node.id)}else{defined.push(v);pattern.push(t.objectProperty(t.clone(id),t.clone(prop.node.id),computed,true))}prop.remove()}if(rest){if(t.isAssignmentExpression(rest)){return}let paramId;if(isIterable){paramId=rest.node.id;pattern[restOffset||pattern.length]=t.restElement(t.clone(paramId))}else if(t.isCallExpression(rest)&&isObjectAssign(rest.get("callee"))){paramId=rest.node.arguments[1];pattern.push(t.restElement(t.clone(paramId)))}else{const filteredOut=rest.get("init.arguments.1.elements");if(Array.isArray(filteredOut)&&filteredOut.length){filteredOut.forEach(p=>{const prop=p.node.value;if(!defined.includes(prop)){pattern.push(t.objectProperty(t.identifier(prop),t.identifier(prop),false,true))}})}paramId=rest.node.id;pattern.push(t.restElement(t.clone(paramId)))}if(t.isVariableDeclaration(rest.parent)||t.isExpressionStatement(rest.parent)){rest.remove()}else{rest.replaceWith(t.clone(paramId))}}if(isIterable){for(let i=pattern.length;i--;){if(!pattern[i])pattern[i]=null}const arr=t.arrayPattern([]);arr.elements=pattern;path.replaceWith(arr)}else{path.replaceWith(t.objectPattern(pattern))}path.scope.crawl();const newIdents=path.getBindingIdentifierPaths();for(let ident in newIdents){if(t.isIdentifier(newIdents[ident])){visitParam(newIdents[ident])}}}return{name:"transform-destructuring",visitor:{Program:{enter(path,state){state.set("assignUsage",new Set)},exit(path,state){const assigns=state.get("assignUsage");const libs=/core-js\/modules\/es\.object\.assign|(^(object-assign|object.assign)$)/;const remaining=Array.from(assigns).filter(p=>!p.removed).length;if(!remaining){path.get("body").forEach(p=>{if(t.isExpressionStatement(p)){p=p.get("expression")}if(t.isCallExpression(p)){if(isImportOf(p,libs)){p.remove()}}})}}},MemberExpression(path,state){if(isObjectAssign(path)){state.get("assignUsage").add(path)}},Function(path){path.get("params").forEach(visitParam)},VariableDeclarator(path,state){if(state.opts.parametersOnly)return;visitParam(path.get("id"))}}}};exports.default=_default;module.exports=exports.default;