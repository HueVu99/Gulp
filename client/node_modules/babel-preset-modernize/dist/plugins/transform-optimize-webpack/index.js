"use strict";exports.__esModule=true;exports.default=_default;const REGISTRY_HINT="webpackJsonp";function _default({types:t,template}){function isWebpackRegistryContext(path){if(t.isAssignmentExpression(path)){return isWebpackRegistryContext(path.get("left"))}if(!t.isMemberExpression(path))return false;const obj=path.get("object").resolve();if(!/^(window|top|self|globalThis)$/.test(getName(obj))){return false}return getName(path.get("property"))===REGISTRY_HINT}function isWebpackBootstrap(path){const identifiers={};path.get("body").traverse({MemberExpression(p){if(p.scope!==path.scope||!t.isAssignmentExpression(p.parent)){return}if(t.isIdentifier(p.node.object)&&t.isIdentifier(p.node.property)){let a=identifiers[p.node.object.name];if(!a)a=identifiers[p.node.object.name]={};a[p.node.property.name]=p}}});for(const a in identifiers){const v=identifiers[a];if(v.p&&v.c&&v.oe){return true}}return!!(identifiers.window&&identifiers.window.webpackJsonp)}function resolveExpressionStatement(path){if(t.isExpressionStatement(path)){return resolveExpressionStatement(path.get("expression"))}if(t.isUnaryExpression(path)&&path.node.operator==="!"){return resolveExpressionStatement(path.get("argument"))}return path}function getName(path){path=path.resolve();if(t.isIdentifier(path))return path.node.name;return path.evaluate().value}function reduceReferences(identifier,callback,accumulator){if(!identifier)return accumulator;const identifiers=identifier.getOuterBindingIdentifierPaths();for(let name in identifiers){const binding=identifiers[name].scope.bindings[name];const paths=binding.referencePaths;if(!binding.constant){console.warn(`Expected constant binding: ${name}`)}for(let i=0;i<paths.length;i++){const path=paths[i];if(path!==identifier){const r=callback(accumulator,paths[i],name);if(r!==undefined)accumulator=r}}}return accumulator}function parseModule(name,factory){const module={name,exports:{},defaultExport:undefined,exportIdentifiers:{},requires:[],references:0,referenceModules:new Set,factory,harmony:false};const[moduleObj,exportsObj,requireObj]=factory.get("params");reduceReferences(moduleObj,(refs,ref)=>{const parent=ref.parentPath;const outer=parent.parentPath;if(t.isCallExpression(parent)){namedExport(parent)}if(!t.isMemberExpression(parent)){console.warn(`Not sure how to deal with ${parent.node.type} on "module".\n${parent.getSource()}`);return}if(t.isMemberExpression(outer)){return namedExport(outer)}if(!t.isAssignmentExpression(outer)){console.warn(`Expected module.exports assignment, but got ${outer.node.type}.\n${outer.getSource()}`);return}const property=getName(parent.get("property"));if(property!=="exports"){console.warn(`Unexpected assignment to module[${property}].\n${parent.getSource()}`);return}const value=outer.get("right");if(t.isObjectExpression(value)&&value.evaluate().confident){if(value.get("properties").every(p=>t.isObjectProperty(p))){const names=[];const v=outer.replaceWithMultiple(value.get("properties").map(p=>{let keyName=t.isIdentifier(p.node.key)?p.node.key.name:p.get("key").evaluate().value;const computed=!t.isValidIdentifier(keyName);const key=computed?t.stringLiteral(keyName):t.identifier(keyName);names.push(keyName);return t.assignmentExpression("=",t.memberExpression(t.clone(outer.node.left),key,computed),t.clone(p.node.value))}));v.forEach((v,i)=>{if(t.isExpressionStatement(v))v=v.get("expression");setExport(v.get("right"),name,names[i])});return}}setExport(value,name,"default")},[]);function namedExport(path){if(t.isCallExpression(path)){if(path.get("arguments").length!==3)return;const nameNode=path.get("arguments.1");const getter=path.get("arguments.2");if(!t.isFunction(getter))return;const v=getter.get("body.body.0.argument");getter.replaceWith(t.arrowFunctionExpression([],v.node));return setExport(v,name,nameNode.evaluate().value)}if(!t.isMemberExpression(path)){console.warn(`Not sure how to deal with ${path.node.type} on "module".\n${path.getSource()}`);return}const parent=path.parentPath;if(!t.isAssignmentExpression(parent)){console.warn(`Expected exports[] assignment, but got ${parent.node.type}.\n${parent.getSource()}`);return}const property=getName(path.get("property"));if(!property){console.warn(`Dynamic exports are not supported.\n${path.getSource()}`);return}if(property==="__esModule"){module.harmony=true}setExport(parent,name,property)}function setExport(parent,moduleName,exportName){const prog=parent.scope.getProgramParent();const ident=prog.generateDeclaredUidIdentifier("_"+moduleName+"$"+exportName);parent.replaceWith(t.assignmentExpression("=",t.clone(ident),t.clone(parent.node)));module.exports[exportName]=parent;module.exportIdentifiers[exportName]=ident;if(exportName==="default")module.defaultExport=parent}reduceReferences(exportsObj,(refs,ref)=>{namedExport(ref.parentPath)},[]);factory.scope.crawl();reduceReferences(requireObj,(refs,ref)=>{const parent=ref.parentPath;if(t.isMemberExpression(parent)){const prop=getName(parent.get("property"));if(/^(r|d|register|define)$/.test(prop))return;console.warn(`Unexpected require.${prop} usage.\n${parent.parentPath.getSource()}`);return}const outer=parent.parentPath;if(!t.isCallExpression(parent)){console.warn(`Expected require() but found ${parent.node.type}.\n${outer.getSource()}`);return}const arg=parent.get("arguments.0");let str;if(t.isLiteral(arg)){str=arg.node.value}else{const v=arg.evaluate();if(!v.confident){console.warn(`Unexpected dynamic require().\n${outer.getSource()}`);return}str=v.value}module.requires.push({specifier:str,path:parent})});return module}function resolveLocalExports(module,modules){for(const req of module.requires){const reference=modules.get(req.specifier);if(reference){reference.referenceModules.add(module);reference.references++}}for(const req of module.requires){const reference=modules.get(req.specifier);if(!reference){console.log("External module reference: ",req.specifier);continue}const parent=req.path.parentPath;if(t.isVariableDeclarator(parent)||t.isAssignmentExpression(parent)){const lhs=t.isVariableDeclarator(parent)?parent.get("id"):parent.get("left");if(t.isObjectPattern(lhs)){const paths=parent.getOuterBindingIdentifierPaths();let deopt=false;for(const name in paths){const ident=paths[name];const imported=ident.parent.key.name;const binding=ident.scope.bindings[name];const exported=reference.exportIdentifiers[imported];if(exported){ident.parentPath.remove()}else{deopt=true;continue}binding.referencePaths.forEach(p=>{p.replaceWith(t.clone(exported))})}if(!deopt){req.path.getStatementParent().replaceWith(req.path.node);return}}}const exported=reference.exportIdentifiers.default;if(exported){req.path.replaceWith(t.sequenceExpression([t.cloneDeep(req.path.node),t.identifier(exported.name)]));const prog=req.path.scope.getProgramParent();const binding=prog.bindings[exported.name];if(binding)binding.reference();const decl=req.path.get("expressions.1");const inlined=forceEvaluate(decl);if(inlined.confident&&(inlined.value===null||typeof inlined.value!=="object")){decl.replaceWith(template.ast(JSON.stringify(inlined.value)));reference.references--;if(reference.references===0){let factory=reference.factory;if(!t.isMethod(factory))factory=factory.parentPath;factory.remove();for(let exp in reference.exportIdentifiers){const ident=reference.exportIdentifiers[exp];const binding=prog.bindings[ident.name];binding.dereference();if(binding.references===0)binding.path.remove()}}req.path.replaceWith(decl.node)}}}}function modernizeImports(module){const resolved=new Map;for(const require of module.requires){const parent=require.path.parentPath;if(t.isVariableDeclarator(parent)){const lhs=[];const paths=parent.getOuterBindingIdentifierPaths();for(let name in paths){const binding=paths[name].scope.bindings[name];if(!binding)continue;for(const ref of binding.referencePaths){if(t.isMemberExpression(ref.parent)){const imported=getName(ref.parentPath.get("property"));let local=resolved.get(imported);if(!local){local=imported;if(!t.isValidIdentifier(local)||ref.scope.hasBinding(local)){local=ref.scope.generateUid(local)}lhs.push(t.objectProperty(t.identifier(imported),t.identifier(local),false,imported===local));resolved.set(imported,local)}let p=ref.parentPath;if(t.isCallExpression(p.parent)&&p.parent.callee.name==="Object"){p=p.parentPath}p.replaceWith(t.identifier(local))}}}parent.get("id").replaceWith(t.objectPattern(lhs));if(parent.parent.declarations.length===1){parent.parent.kind="const"}parent.scope.crawl()}}}function hoistSharedModules(module,modules){for(const exported in module.exports){const parent=module.exports[exported];let resolved=parent.get("right").resolve();const left=parent.get("left");let root,functionDecl;const prog=resolved.scope.getProgramParent();let innerValue=resolved;if(t.isAssignmentExpression(innerValue)){innerValue=innerValue.get("right")}let hoist=innerValue.isPure();const evaluated=innerValue.evaluate();if(evaluated.confident){hoist=true}else if(t.isFunction(resolved)){const bindings=module.factory.get("body").scope.bindings;for(let i in bindings){if(bindings[i].referencePaths.some(p=>resolved.isAncestor(p))){hoist=false;break}}}if(hoist){let bindings=resolved.getOuterBindingIdentifierPaths();if(t.isFunctionDeclaration(resolved)||t.isClassDeclaration(resolved)){const n=functionDecl=resolved.node;let node;if(t.isClassDeclaration(resolved)){node=t.classExpression(n.id,n.superClass,n.body)}else{node=t.functionExpression(n.id,n.params,n.body);node.generator=n.generator;node.async=n.async}const expr=root=resolved.replaceWith(template.ast`var ${n.id}=${node}`)[0];resolved=expr.get("declarations.0.init")}const hoisted=resolved.hoist(prog);if(!hoisted){if(functionDecl){root.replaceWith(functionDecl)}continue}let finalId=left.node;if(!t.isIdentifier(finalId)){console.log(finalId)}const renamed={};if(functionDecl){hoisted.parentPath.scope.crawl();const binding=hoisted.parentPath.scope.bindings[hoisted.parent.id.name];if(!hoisted.parentPath.scope.checkBlockScopedCollisions(binding)){renamed[hoisted.parent.id.name]=functionDecl.id.name;hoisted.parentPath.scope.rename(hoisted.parent.id.name,functionDecl.id.name)}}const ident=hoisted.parent.id;for(let i in bindings){const binding=resolved.scope.getBinding(i);binding.referencePaths.forEach(p=>{binding.dereference();p.replaceWith(t.clone(ident))});if(!binding.references)binding.path.remove()}hoisted.parentPath.scope.crawl();hoisted.parentPath.scope.bindings[ident.name].referencePaths.forEach(p=>{if(t.isAssignmentExpression(p.parent)&&t.isNodesEquivalent(p.getOpposite(),left)){p.parentPath.replaceWith(t.clone(finalId))}else{p.replaceWith(t.clone(finalId))}});hoisted.parentPath.get("id").replaceWith(t.clone(finalId));hoisted.parentPath.scope.getBinding(finalId.name).path.remove()}}}function forceEvaluate(path){let ret=path.evaluate();if(ret.deopt){const resolved=forceResolve(ret.deopt);if(resolved&&resolved!==ret.deopt){return forceEvaluate(resolved)}if(t.isAssignmentExpression(resolved)){if(resolved.node.operator==="="){return forceEvaluate(resolved.get("right"))}}}return ret}function forceResolve(path){let ret=path.resolve();if(!ret.node){if(t.isVariableDeclarator(path)){const bindings=path.getOuterBindingIdentifierPaths();const binding=path.scope.bindings[Object.keys(bindings)[0]];if(binding.constantViolations&&binding.constantViolations.length===1){return forceResolve(binding.constantViolations[0])}}if(t.isAssignmentExpression(path)){if(path.node.operator==="="){return forceResolve(path.get("right"))}}}return path}return{name:"transform-optimize-webpack",visitor:{Program(path,state){const body=path.get("body").filter(t.isStatement);if(body.length!==1)return;const root=resolveExpressionStatement(body[0]);if(!t.isCallExpression(root))return;const callee=root.get("callee");const filename=path.hub.file.filename||path.hub.file.metadata.filename||"<file>";let hasRuntime=false;let isEntry=null;if(t.isFunction(callee)){if(isWebpackBootstrap(callee))return console.log("not a webpack bootstrap");hasRuntime=true}else{if(!t.isMemberExpression(callee))return;const method=getName(callee.get("property"));if(method!=="push")return;const obj=callee.get("object");if(!isWebpackRegistryContext(obj)){console.info(filename+" is not a webpack bundle.");return}}console.info(`${filename} is a Webpack bundle (${isEntry?"entry":"non-entry"}, ${hasRuntime?"with runtime":"no runtime"}).`);root.get("arguments").forEach(chunk=>{let modulesProps=chunk.get("elements.1")||chunk;const modules=new Map;state.set("modules",modules);let offset=0;if(t.isCallExpression(modulesProps)){const callee=modulesProps.get("callee");if(t.isMemberExpression(callee)&&t.isCallExpression(callee.get("object"))&&getName(callee.get("object.callee"))==="Array"&&getName(callee.get("property"))==="concat"){const args=callee.get("object.arguments");if(args.length!==1||!t.isNumericLiteral(args[0])){console.error("Unknown webpackJsonp chunk format: "+callee.getSource());return}offset=args[0].node.value;modulesProps=modulesProps.get("arguments.0")}else{console.warn("Unknown webpackJsonp expression: "+callee.getSource())}}if(t.isObjectExpression(modulesProps)){modulesProps.get("properties").forEach(m=>{const key=getName(m.get("key"));const method=t.isObjectMethod(m)?m:m.get("value");const module=parseModule(key,method);modules.set(key,module)})}else if(t.isArrayExpression(modulesProps)){modulesProps.get("elements").forEach((method,index)=>{const key=offset+index;if(!method.node){console.warn(`Missing information for module ID ${key} (offset ${offset}). Possibly corrupted bundle.`);return}const module=parseModule(key,method);modules.set(key,module)})}for(let module of modules.values()){modernizeImports(module);resolveLocalExports(module,modules);hoistSharedModules(module,modules)}let out={};modules.forEach((v,k)=>{out[k]=v});console.log("modules: ",out)})}}}}module.exports=exports.default;