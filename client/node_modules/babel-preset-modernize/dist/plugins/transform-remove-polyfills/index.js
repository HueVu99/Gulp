"use strict";exports.__esModule=true;exports.default=transformRemovePolyfills;const POLYFILLS=["Object.assign","Object.create","Object.define","Object.hasOwnProperty","Object.getOwnProperties","Object.setPrototypeOf","Object.getPrototypeOf","Object.getOwnPropertyDescriptor","Object.getOwnPropertyDescriptors","Object.getOwnPropertySymbols","Object.keys","Array.from","Symbol","Symbol.for","WeakMap","WeakSet","Map","Set","Promise","Promise.all","Promise.resolve","Promise.reject","fetch","Headers","Response","Request","FormData","ArrayBuffer","FileReader","URLSearchParams","URL","JSON","JSON.parse","JSON.stringify","Function.toString","setTimeout","clearTimeout","setInterval","clearInterval","Number.isFinite","Math","Math.max","Math.min","Math.ceil","Math.floor"];const IS_BROWSER=true;if(IS_BROWSER){POLYFILLS.push("window","self","Math")}function transformRemovePolyfills({types:t,template}){function getName(path){if(t.isMemberExpression(path)){return getName(path.get("object"))+"."+getName(path.get("property"))}path=path.resolve();if(!path.node)return;if(!t.isIdentifier(path))return;const scalar=path.evaluate();if(scalar.confident){if(typeof scalar.value==="object"){console.error("Path evaluated to a non-primitive value: ",scalar.value)}return String(scalar.value)}return path.node.name}function isPolyfillIdentifier(path,polyfills,ignoreScope){if(t.isMemberExpression(path)){let obj=path.get("object").resolve();if(t.isIdentifier(obj)&&/^(window|global|self|globalThis)$/.test(obj.node.name)&&!obj.scope.hasBinding(obj.node.name,true)){return isPolyfillIdentifier(path.get("property"),polyfills,true)}}const str=getName(path);if(!str)return false;for(let pattern of polyfills){if(str.match(pattern)){const root=(t.isMemberExpression(path)?path.get("object"):path).resolve();if(ignoreScope!==false&&root.node&&root.scope.hasBinding(root.node.name,true)){console.warn("Tainted polyfill identifier "+str);return false}return str}}return false}function handlePolyfillAssignment(right){if(!t.isLogicalExpression(right)||right.node.operator!=="||")return;const api=right.get("left");if(isPolyfillIdentifier(api,POLYFILLS)){right.replaceWith(t.clone(api.node));return api.node}}function replaceHelperWithNative(path,native){const helper=path.resolve();const binding=helper.scope.getBinding(helper.node.name);if(!binding){console.warn("Unknown binding: ",helper);return}binding.referencePaths.forEach(p=>{if(typeof native==="function"){native(p)}else{if(t.isExportSpecifier(p.parent))return;binding.dereference();p.replaceWith(t.clone(native))}});if(!binding.references){binding.path.remove()}else{console.log(`Failed to remove ${binding.identifier.name} due: ${binding.references} unremovable bindings`)}}function cascadeReplacement(path,value){const parent=path.parentPath;const isFalsy=t.isBooleanLiteral(value)&&!value.value||t.isNullLiteral(value)||t.isIdentifier(value)&&value.name==="undefined"||t.isUnaryExpression(value)&&value.operator==="void";const truthy=isFalsy?false:value.evaluateTruthy?value.evaluateTruthy():true;if(t.isLogicalExpression(parent)){if(path.key==="right"){return parent}let replacement;switch(parent.node.operator){case"&&":replacement=truthy?t.clone(path.getOpposite().node):t.booleanLiteral(false);break;case"||":replacement=t.clone(truthy?path.node:path.getOpposite().node);break;default:console.error("Unknown operator "+parent.node.operator,parent.getSource());}parent.replaceWith(replacement);return cascadeReplacement(parent,replacement)||parent}if(t.isConditionalExpression(parent)){const selected=truthy?"consequent":"alternate";const replacement=t.clone(parent.get(selected).node);parent.get(getOtherKey(selected)).replaceWith(t.nullLiteral());parent.replaceWith(replacement);return cascadeReplacement(parent,replacement)||parent}if(t.isUnaryExpression(parent)){if(parent.node.prefix&&parent.node.operator==="typeof"){if(isPolyfillIdentifier(path,POLYFILLS)){console.log("unary --> polyfill",parent.node);if(t.isBinaryExpression(parent.parentPath)){const other=parent.getOpposite().evaluate();if(other.confident){const negate=parent.parent.operator[0]==="!";let truthy=other.value!=="undefined";if(negate)truthy=!truthy;const replacement=t.booleanLiteral(truthy);parent.parentPath.replaceWith(replacement);return cascadeReplacement(parent.parentPath,replacement)}}}}}if(t.isCallExpression(parent)){const fn=parent.get("callee").resolve();if(t.isFunction(fn)){const out=attemptInlineEvaluation(parent);if(out&&out.confident){parent.replaceWith(out.value)}}}if(t.isReturnStatement(parent)){console.log("RETURN");console.log(parent.node.argument)}if(t.isIdentifier(path)){if(isPolyfillIdentifier(path,POLYFILLS)){const replacement=path.resolve().node;path.replaceWith(replacement);return cascadeReplacement(path.parentPath,replacement)}}}function attemptInlineEvaluation(path,replacement){const old=path.node;const callee=path.get("callee").resolve();if(!t.isFunction(callee))return{confident:false};const argValues=path.node.arguments;path.replaceWith(t.callExpression(t.arrowFunctionExpression(callee.node.params,callee.node.body),[]));const params=path.get("callee.params");for(let index=params.length;index--;){const param=params[index];const binding=param.scope.getBinding(param.node.name);binding.referencePaths.forEach(p=>{p.replaceWith(argValues[index]?t.clone(argValues[index]):p.scope.buildUndefinedNode())});param.scope.removeBinding(binding.name);param.remove()}path.get("callee.body").traverse(visitor);let toReturn;const ret=path.get("callee.body.body").find(p=>t.isReturnStatement(p));const scope=path.get("callee.body").scope;scope.crawl();if(path.get("callee.body.body").length<=1&&Object.keys(scope.bindings).length===0&&Object.keys(scope.globals).length===0){toReturn=ret.get("argument")}const evaled=path.get("callee.body").evaluate();path.replaceWith(old);if(!evaled.confident){evaled.confident=!!toReturn;evaled.value=toReturn}if(evaled.confident){const calleeBinding=callee.scope.getBinding(getFunctionIdentifier(callee));if(calleeBinding){calleeBinding.dereference();if(!calleeBinding.referenced){callee.remove()}}}return evaled}const keys=[["alternate","consequent"],["left","right"]];function getOtherKey(key){for(const pair of keys){if(pair[0]===key)return pair[1];if(pair[1]===key)return pair[0]}}function getFunctionIdentifier(path){const id=path.get("id");if(id&&id.node)return id;const parent=path.parentPath;if(t.isFunction(parent)){return getFunctionIdentifier(parent)}if(t.isVariableDeclarator(parent)){return parent.get("id")}}function handleFunctionConstructor(args){args=args.slice();const body=args.pop();if(!t.isStringLiteral(body.node))return;const tpl=template.ast("{"+body.node.value+"}");return t.functionExpression(null,args,tpl)}let visitor;return{name:"transform-remove-polyfills",visitor:visitor={Identifier(path){},LogicalExpression(path){const operator=path.node.operator;const left=path.get("left");const right=path.get("right");const polyfillGuard=isPolyfillIdentifier(left,POLYFILLS);let isTruthy=polyfillGuard;if(!isTruthy){isTruthy=left.evaluateTruthy();if(isTruthy===undefined)return}if(isTruthy){let replacement;if(operator==="&&"){replacement=right.node}else if(operator==="||"){replacement=left.node}if(replacement){path.replaceWith(t.clone(replacement))}}},BinaryExpression(path){const operator=path.node.operator;const left=path.get("left");const right=path.get("right");if((t.isIdentifier(left)||t.isMemberExpression(left))&&(t.isIdentifier(right)||t.isMemberExpression(right))){const leftIdent=isPolyfillIdentifier(left,POLYFILLS);const rightIdent=isPolyfillIdentifier(right,POLYFILLS);if(leftIdent&&leftIdent===rightIdent){if(operator==="=="||operator==="==="){path.replaceWith(t.booleanLiteral(true));return}if(operator==="!="||operator==="!=="){path.replaceWith(t.booleanLiteral(false));return}}}},CallExpression(path){const callee=path.get("callee").resolve();if(t.isIdentifier(callee)&&callee.node.name==="Function"){const fn=handleFunctionConstructor(path.get("arguments"));if(fn){path.replaceWith(fn);if(t.isCallExpression(path.parentPath)&&fn.body.body.length===1&&t.isReturnStatement(fn.body.body[0])&&t.isThisExpression(fn.body.body[0].argument)){path.parentPath.replaceWith(t.nullLiteral())}}}},MemberExpression(path){},UnaryExpression(path){if(path.node.prefix&&path.node.operator==="typeof"){if(isPolyfillIdentifier(path.get("argument"),POLYFILLS)){cascadeReplacement(path.get("argument"),path.get("argument").node)}}},AssignmentExpression(path,scope){if(path.node.operator!=="=")return;const native=handlePolyfillAssignment(path.get("right"));if(native){replaceHelperWithNative(path.get("left"),native)}},VariableDeclarator(path,scope){const native=handlePolyfillAssignment(path.get("init"));if(native){replaceHelperWithNative(path.get("id"),native)}},ObjectProperty(path){if(t.isFunctionExpression(path.get("value"))&&(!path.node.value.id||t.isNodesEquivalent(path.node.value.id,path.node.key))){const fn=path.node.value;const method=t.objectMethod("method",path.node.key,fn.params,fn.body,path.node.computed);method.async=fn.async;method.generator=fn.generator;method.decorators=path.node.decorators;path.replaceWith(method)}else if(!path.node.computed){path.node.shorthand=true}},DirectiveLiteral(path){if(path.node.value==="use strict"){path.parentPath.remove()}}}}}module.exports=exports.default;