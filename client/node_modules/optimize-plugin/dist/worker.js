function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var terser = require('terser');
var babel = _interopDefault(require('@babel/core'));

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Detects and analyzes a Webpack "entry" bundle, allowing String transformations on its internal chunk URL map.
 *
 * @example
 * {
 *   plugins: [
 *     ['./transform-change-webpack-urls', {
 *       pattern: /\.js$/,
 *       replacement: '.legacy.js'
 *     }]
 *   ]
 * }
 *
 * @see https://astexplorer.net/#/gist/0995f8452cfa62d797a2a778a3442b65/2e588cc89829971495ca8e38905bb5581a23cf5d
 */

/** @typedef NodePath @type {import('@babel/core').NodePath} */
function transformWebpackUrls ({
  types: t
}) {
  function unwrap(path) {
    if (t.isExpressionStatement(path)) {
      return unwrap(path.get('expression'));
    }

    if (t.isUnaryExpression(path) && path.node.operator === '!') {
      return unwrap(path.get('argument'));
    }

    return path;
  }
  /**
   * Attempt to parse a path and find a webpack Bootstrap function, if so returning a description.
   * @param {NodePath} path
   */


  function getWebpackBootstrap(path) {
    path = unwrap(path);
    if (!t.isCallExpression(path)) return false;
    const factory = path.get('callee');
    if (!t.isFunctionExpression(factory)) return false;
    const bootstrap = parseWebpackBootstrap(factory);
    if (!bootstrap || !bootstrap.confident) return false;
    const args = path.get('arguments');
    bootstrap.modules = getWebpackModules(args);
    return bootstrap;
  }
  /**
   * Verify that a Path is a "bootstrap" function, which is Webpack's module registry and loader implementation.
   * @param {NodePath} path
   */


  function parseWebpackBootstrap(path) {
    const bootstrap = {
      confident: false,

      /** @type {NodePath} */
      factory: null,

      /** @type {NodePath} */
      urlMap: null
    }; // // TODO: this is silly and should use binding lookup + parent checks. Something like:
    // const bindings = path.get('body').scope.bindings;
    // console.log(path.get('body').scope.hasGlobal('window'));
    // for (let name in bindings) {
    //   const binding = bindings[name];
    //   if (1){}
    // }
    // bindings.some(b => {
    //   b.referencePaths.some(p => t.isMemberExpression(p.parent) && t.isAssignmentExpression(p.parentPath.parent) && p.parent.property.name === 'oe')
    // });

    const identifiers = {};
    path.get('body').traverse({
      MemberExpression(p) {
        // Find the script loader function (indicated by the presence of document.createElement("script").
        // Note that this check *does* traverse into nested functions.
        if (t.matchesPattern(p.node, 'document.createElement') && t.isCallExpression(p.parent) && t.isStringLiteral(p.parent.arguments[0], {
          value: 'script'
        })) {
          const id = p.parentPath.parent.id.name;
          p.scope.getBinding(id).referencePaths.forEach(p => {
            // Find script.src= assignment mapping:
            const parent = p.parentPath;

            if (t.isMemberExpression(parent) && t.isIdentifier(parent.node.property, {
              name: 'src'
            }) && t.isAssignmentExpression(parent.parent)) {
              // Find the assigned value: s.src = X
              let expr = parent.parentPath.get('right').resolve(); // It might be a function call:

              if (t.isCallExpression(expr)) {
                expr = expr.get('callee').resolve();
              } // That function call might be an IIFE (it generally is):


              if (t.isFunction(expr)) {
                expr = expr.get('body.body').filter(t.isReturnStatement)[0];
                if (expr) expr = expr.get('argument');
              } // Store it for later manipulation


              bootstrap.urlMap = expr;
            }
          });
          return;
        } // Detect extensions to Webpack's main namespace.
        // They're assignments to properties on a local binding, but we don't yet know which one.
        // We ignore nested functions, and only look at assignments.


        if (p.scope !== path.scope || !t.isAssignmentExpression(p.parent)) {
          return;
        }

        if (t.isIdentifier(p.node.object) && t.isIdentifier(p.node.property)) {
          let a = identifiers[p.node.object.name];
          if (!a) a = identifiers[p.node.object.name] = {};
          a[p.node.property.name] = p;
        }
      }

    }); // shallowWalk(path.get('body'), p => {
    //  if (!t.isMemberExpression(p)) return;
    //  if (t.isIdentifier(p.node.object) && t.isIdentifier(p.node.property)) {
    //    let a = identifiers[p.node.object.name];
    //    if (!a) a = identifiers[p.node.object.name] = {};
    //    a[p.node.property.name] = true;
    //  }
    // });
    // Check if we found a binding with properties that signify a Webpack namespace object:

    for (const a in identifiers) {
      const v = identifiers[a]; // Look for `__webpack_public_path__`, `__webpack_modules__` and an onerror handler:

      if (v.p && v.c && v.oe) {
        bootstrap.confident = true;
        bootstrap.factory = path; // might be useful later

        bootstrap.api = v;
        break;
      }
    } // Regardless of structure, a `window.webpackJsonp` reference means this is a webpack bootstrap function:


    if (identifiers.window && identifiers.window.webpackJsonp) {
      bootstrap.confident = true;
      bootstrap.factory = path;
      bootstrap.webpackJsonp = identifiers.window.webpackJsonp;
    }

    return bootstrap;
  }

  function getWebpackModules(list) {
    const modules = [];

    const mod = m => {
      if (t.isFunctionExpression(m)) {
        modules.push(m);
      } else {
        throw Error('Not a webpack bundle');
      }
    };

    list.forEach(m => {
      if (t.isArrayExpression(m)) {
        m.get('elements').forEach(mod);
      } else {
        mod(m);
      }
    });
    return modules;
  } // function shallowWalk(path, callback) {
  //   if (Array.isArray(path)) {
  //     for (let i=0; i<path.length; i++) shallowWalk(path[i], callback);
  //   }
  //   else if (t.isVariableDeclaration(path)) {
  //     shallowWalk(path.get('declarations'), callback);
  //   }
  //   else if (t.isVariableDeclarator(path)) {
  //     shallowWalk(path.get('id'), callback);
  //     shallowWalk(path.get('init'), callback);
  //   }
  //   else if (t.isBlockStatement(path)) {
  //     shallowWalk(path.get('body'), callback);
  //   }
  //   else if (t.isExpressionStatement(path)) {
  //     shallowWalk(path.get('expression'), callback);
  //   }
  //   else if (t.isAssignmentExpression(path)) {
  //     shallowWalk(path.get('left'), callback);
  //     shallowWalk(path.get('right'), callback);
  //   }
  //   else if (t.isSequenceExpression(path)) {
  //     shallowWalk(path.get('expressions'), callback);
  //   }
  //   else if (t.isUnaryExpression(path)) {
  //     shallowWalk(path.get('argument'), callback);
  //   }
  //   else if (!t.isFunction(path)) {
  //     callback(path);
  //   }
  // }


  return {
    name: 'transform-change-webpack-urls',
    visitor: {
      Program(path, state) {
        const opts = state.opts || {};
        const pattern = opts.pattern || /\.js$/;
        const replacement = opts.replacement || '.modern.js';
        path.get('body').forEach(expr => {
          const bootstrap = getWebpackBootstrap(expr);
          if (!bootstrap) return; // Replace the template part containing ".js" with ".module.js"

          if (bootstrap.urlMap) {
            bootstrap.urlMap.traverse({
              StringLiteral(s) {
                if (/\.js$/.test(s.node.value)) {
                  s.replaceWith(t.stringLiteral(s.node.value.replace(pattern, replacement)));
                  s.stop();
                }
              }

            });
          }
        });
      }

    }
  };
}

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function extractPolyfills () {
  return {
    name: 'transform-extract-polyfills',
    visitor: {
      ImportDeclaration(path, state) {
        state.opts.onPolyfill(path.node.source.value);
        path.remove();
      }

    }
  };
}

/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Convert a Babel-style SourceMap to Terser-style, parsing if necessary.
 * @param {(import('@babel/core').BabelFileResult)['map']|string|null} map
 * @return {import('source-map').RawSourceMap|null} map
 * @todo This should be deleted, as it's exclusively to make TypeScript happy.
 */
function toTerserMap(map) {
  if (typeof map === 'string') map = JSON.parse(map);
  return typeof map === 'object' && map ? _extends({}, map, {
    version: String(map.version)
  }) : null;
}
/**
 * Convert a Terser-style SourceMap to Babel-style, parsing if necessary.
 * @param {import('source-map').RawSourceMap|string|null} map
 * @returns {(import('@babel/core').BabelFileResult)['map']|null}
 * @todo This should be deleted, as it's exclusively to make TypeScript happy.
 */

function toBabelMap(map) {
  if (typeof map === 'string') map = JSON.parse(map);
  return typeof map === 'object' && map ? _extends({
    file: ''
  }, map, {
    version: parseInt(map.version, 10)
  }) : null;
}
function createPerformanceTimings() {
  const timings = [];

  const start = name => {
    timings.push({
      name,
      start: Date.now()
    });
  };

  const end = name => {
    for (const entry of timings) {
      if (entry.name === name) {
        entry.end = Date.now();
        entry.duration = entry.end - entry.start;
        return;
      }
    }
  };

  return {
    timings,
    start,
    end
  };
}

const NAME = 'OptimizePlugin';
const TERSER_CACHE = {};
const noopTimings = {
  timings: [],
  start: n => {},
  end: n => {}
};
/**
 * @param {object} $0
 * @param {string} $0.file
 * @param {string} $0.source
 * @param {string|object} $0.map
 * @param {object} [$0.options]
 * @param {boolean} [$0.options.timings = false]
 * @param {boolean} [$0.options.minify = false]
 * @param {boolean} [$0.options.downlevel = false]
 * @param {boolean} [$0.options.modernize = false]
 * @param {number} [$0.options.corejsVersion]
 */

async function process({
  file,
  source,
  map,
  options = {}
}) {
  const {
    timings,
    start,
    end
  } = options.timings ? createPerformanceTimings() : noopTimings;
  const {
    minify,
    downlevel,
    modernize
  } = options;
  const polyfills = new Set();
  let legacy;
  const outputOptions = {
    compact: minify,
    minified: minify,
    // envName: minify ? 'production' : 'development',
    comments: minify ? false : undefined,
    generatorOpts: {
      concise: true
    }
  };
  start('modern');
  const modern = await babel.transformAsync(source, _extends({
    configFile: false,
    babelrc: false,
    filename: file,
    inputSourceMap: map,
    sourceMaps: true,
    sourceFileName: file,
    sourceType: 'module',
    envName: 'modern',
    // ast: true,
    presets: [['@babel/preset-env', {
      loose: true,
      modules: false,
      bugfixes: true,
      targets: {
        esmodules: true
      },
      // corejs: options.corejsVersion,
      useBuiltIns: false
    }], modernize && ['babel-preset-modernize', {
      loose: true,
      webpack: true
    }]].filter(Boolean)
  }, outputOptions, {
    caller: {
      supportsStaticESM: true,
      name: NAME + '-modern'
    }
  }));
  end('modern');

  if (minify) {
    start('modern-minify');
    const minified = terser.minify(modern.code, {
      // Enables shorthand properties in objects and object patterns:
      ecma: 2017,
      module: false,
      nameCache: TERSER_CACHE,
      // sourceMap: true,
      sourceMap: {
        content: toTerserMap(modern.map)
      },
      compress: {
        global_defs: {
          MODERN_MODE: true,
          'process.env.NODE_ENV': global.process.env.NODE_ENV || 'production'
        }
      },
      // Fix Safari 10 issues
      // ({a}) --> ({a:a})
      // !await a --> !(await a)
      safari10: true,
      mangle: {// safari10: true
        // properties: {
        //   regex: /./
        // }
      }
    });
    modern.code = minified.code;
    modern.map = toBabelMap(minified.map); // @todo this means modern.ast is now out-of-sync with modern.code
    // can this work? or do we need to run Terser separately for modern/legacy?

    end('modern-minify');
  }

  if (downlevel) {
    start('legacy'); // legacy = await babel.transformFromAstAsync(modern.ast, modern.code, {

    legacy = await babel.transformAsync(modern.code, _extends({
      configFile: false,
      babelrc: false,
      filename: file,
      inputSourceMap: modern.map,
      sourceMaps: true,
      sourceFileName: file,
      sourceType: 'module',
      envName: 'legacy',
      presets: [['@babel/preset-env', {
        loose: true,
        modules: false,
        // corejs: 3,
        corejs: options.corejsVersion,
        useBuiltIns: 'usage'
      }]],
      plugins: [[transformWebpackUrls, {
        pattern: /\.js$/,
        replacement: '.legacy.js'
      }], [extractPolyfills, {
        onPolyfill(specifier) {
          polyfills.add(specifier);
        }

      }]]
    }, outputOptions, {
      caller: {
        supportsStaticESM: false,
        name: NAME + '-legacy'
      }
    }));
    end('legacy');
  }

  return {
    modern: sanitizeResult(modern),
    legacy: legacy && sanitizeResult(legacy),
    polyfills: Array.from(polyfills),
    timings
  };
}

function sanitizeResult(result) {
  return {
    source: result.code,
    map: result.map
  };
}

exports.process = process;
//# sourceMappingURL=worker.js.map
